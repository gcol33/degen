% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bayesian.R
\name{compare_posteriors}
\alias{compare_posteriors}
\title{Compare posterior distributions}
\usage{
compare_posteriors(
  spec_a,
  spec_b,
  y,
  samples_a,
  samples_b,
  n_compare = 100,
  tol = 1e-06,
  progress = interactive()
)
}
\arguments{
\item{spec_a}{A \code{model_spec} object for model A}

\item{spec_b}{A \code{model_spec} object for model B}

\item{y}{Numeric vector of observed data}

\item{samples_a}{Matrix or data frame of posterior samples for model A.
Rows are samples, columns are parameters (named to match spec_a).}

\item{samples_b}{Matrix or data frame of posterior samples for model B.
Rows are samples, columns are parameters (named to match spec_b).}

\item{n_compare}{Number of sample pairs to compare (default 100)}

\item{tol}{Tolerance for likelihood equivalence}

\item{progress}{Logical; show progress bar}
}
\value{
An S3 object of class \code{posterior_comparison} containing:
\describe{
\item{prop_matched}{Proportion of A samples that could be matched by B}
\item{discrepancies}{Vector of likelihood discrepancies}
\item{equivalent}{Logical; overall equivalence conclusion}
\item{summary}{Summary statistics of comparison}
}
}
\description{
Test whether two models produce equivalent posterior predictive distributions
using MCMC samples.
}
\details{
For each posterior sample from model A, this function finds the closest
matching posterior sample from model B (in terms of likelihood) and
computes the discrepancy. If models are equivalent, posterior samples
from different parameterizations should produce similar likelihoods.

This approach does not require the models to have the same parameterization
or even the same number of parameters.
}
\examples{
\donttest{
# Two equivalent models
exp_spec <- model_spec(
  loglik_fn = function(y, lambda) sum(dexp(y, rate = lambda, log = TRUE)),
  par_names = "lambda",
  par_bounds = list(lambda = c(1e-6, 100)),
  name = "Exponential"
)

gamma_spec <- model_spec(
  loglik_fn = function(y, rate) sum(dgamma(y, shape = 1, rate = rate, log = TRUE)),
  par_names = "rate",
  par_bounds = list(rate = c(1e-6, 100)),
  name = "Gamma(1)"
)

# Simulate "posterior" samples (in practice, use actual MCMC output)
set.seed(123)
y <- rexp(50, rate = 2)

# Simple posterior approximation (replace with real MCMC samples)
samples_a <- data.frame(lambda = rgamma(200, shape = 50, rate = 25))
samples_b <- data.frame(rate = rgamma(200, shape = 50, rate = 25))

result <- compare_posteriors(exp_spec, gamma_spec, y, samples_a, samples_b,
                             n_compare = 50)
print(result)
}
}
